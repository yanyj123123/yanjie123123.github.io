<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanyj123123.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="leetcode">
<meta property="og:url" content="https://yanyj123123.github.io/master/2023/06/02/leetcode/index.html">
<meta property="og:site_name" content="MyBlog">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-02T01:37:35.000Z">
<meta property="article:modified_time" content="2023-06-09T09:16:36.228Z">
<meta property="article:author" content="GunTongXiYiJi">
<meta property="article:tag" content="-leetcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yanyj123123.github.io/master/2023/06/02/leetcode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode | MyBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MyBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yanyj123123.github.io/master/2023/06/02/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GunTongXiYiJi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-02 09:37:35" itemprop="dateCreated datePublished" datetime="2023-06-02T09:37:35+08:00">2023-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-09 17:16:36" itemprop="dateModified" datetime="2023-06-09T17:16:36+08:00">2023-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">-leetcode刷题笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/06/02/leetcode/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/06/02/leetcode/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<hr>
<hr>
<span id="more"></span>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树基本知识"><a href="#二叉树基本知识" class="headerlink" title="二叉树基本知识"></a>二叉树基本知识</h2><p>详情见  <a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">二叉树基础</a></p>
<p>二叉树的构建</p>
<!--more-->

<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class treenode&#123;
    int val;
    treenode left;
    treenode right;
    treenode()&#123;&#125;;
    treenode(int val)&#123;this.val&#x3D;val;&#125;
    treenode(int val,treenode left,treenode right)&#123;
        this.val&#x3D;val;
        this.left&#x3D;left;
        this.right&#x3D;right;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>一.递归的写法（递归三要素）</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p>
<!--more-->

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-02 11:11:42
 * @description: 前序递归遍历
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public void preOrder(List&lt;Integer&gt;list,TreeNode root)&#123;
        if(root&#x3D;&#x3D;null)&#123;
            return;
        &#125;
        list.add(root.val);
        preOrder(list,root.left);
        preOrder(list, root.right);
    &#125;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt;list&#x3D;new ArrayList&lt;&gt;();
        preOrder(list, root);
        return list;  

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></p>
<!--more-->

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-02 11:27:08
 * @description: 二叉树的中序递归遍历
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public void inorder(TreeNode root,List&lt;Integer&gt;list)&#123;
        if(root&#x3D;&#x3D;null)&#123;
            return;
        &#125;
        inorder(root.left,list);
        list.add(root.val);
        inorder(root.right, list);
    &#125;
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt;list&#x3D;new ArrayList&lt;&gt;();
        inorder(root, list);
        return list;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/"><strong><strong><strong>145.二叉树的后序遍历</strong></strong></strong></a></p>
<!--more-->

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-02 11:31:31
 * @description: 二叉树的后序遍历2
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public void postorder(TreeNode root,List&lt;Integer&gt;list)&#123;
        if(root&#x3D;&#x3D;null)&#123;
            return;
        &#125;
        postorder(root.left,list);
        postorder(root.right, list);
        list.add(root.val);
        
    &#125;
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt;list&#x3D;new ArrayList&lt;&gt;();
        postorder(root, list);
        return list;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>通常是用<strong>栈</strong>来模拟递归</p>
<h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><!--more-->

<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-02 16:16:26
 * @description: 使用栈加迭代法进行前序遍历
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();
        if (root &#x3D;&#x3D; null)&#123;
            return result;
        &#125;
        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();
        stack.push(root);
        while (!stack.isEmpty())&#123;
            TreeNode node &#x3D; stack.pop();
            result.add(node.val);
            &#x2F;&#x2F;因为栈是先进后出，所以需要右孩子先入栈，这样左孩子才能先弹出
            if (node.right !&#x3D; null)&#123;
                stack.push(node.right);
            &#125;
            if (node.left !&#x3D; null)&#123;
                stack.push(node.left);
            &#125;
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><!--more-->

<p>与前序和后序遍历不同，中序遍历需要使用一个指针来帮助访问结点，栈来存储已经访问过的结点，所以需要定义一个结点</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">TreeNode cur&#x3D;root;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后将先查找到最左节点，再将栈里面的节点弹出。代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-02 16:18:16
 * @description: 使用迭代法进行中序遍历，与前序和后序不同
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt;list&#x3D;new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt;stack&#x3D;new Stack&lt;&gt;();
        TreeNode cur&#x3D;root;
        while(cur!&#x3D;null||!stack.isEmpty())&#123;
            if(cur!&#x3D;null)&#123;
                stack.push(cur);
                cur&#x3D;cur.left;
            &#125;
            else&#123;
                cur&#x3D;stack.pop();
                list.add(cur.val);
                cur&#x3D;cur.right;
            &#125;
        &#125;
        return list; 
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>前序是左中右，后序是左右中，所以只需在前序遍历代码稍作修改，然后对列表进行反转即可</p>
<p>对列表进行翻转</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Collections.reverse(result);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<!--more-->

<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();
        if (root &#x3D;&#x3D; null)&#123;
            return result;
        &#125;
        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();
        stack.push(root);
        while (!stack.isEmpty())&#123;
            TreeNode node &#x3D; stack.pop();
            result.add(node.val);
            &#x2F;&#x2F;由于后序是左右中，所以仅需在前序的基础上调整即可，然后对集合进行翻转
            if (node.left !&#x3D; null)&#123;
                stack.push(node.left);
            &#125;
            if (node.right !&#x3D; null)&#123;
                stack.push(node.right);
            &#125;
        &#125;
        Collections.reverse(result);
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="层序遍历（使用队列"><a href="#层序遍历（使用队列" class="headerlink" title="层序遍历（使用队列)"></a>层序遍历（使用队列)</h3><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历</a></h4><p>二叉树的层序遍历其实就是图的广度优先搜索，需要使用队列来存储结点。下面是需要注意的地方</p>
<ul>
<li><p>为了记录某层的结点是否已经全部出队，需要记录每层结点个数。因为可能会出现不同层的结点在队列中，这样会出现混淆的情况。</p>
</li>
<li><p>需要使用两个循环，大循环是将每一层的节点集合添加进结果中，小循环是添加每一层的结点并加入后续入队结点。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-07 10:34:48
 * @description: 二叉树的层序遍历
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Deque&lt;TreeNode&gt;deque&#x3D;new ArrayDeque&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt;result&#x3D;new ArrayList&lt;&gt;();
        
        if(root!&#x3D;null)&#123;
            deque.add(root);
        &#125;
        int count&#x3D;0;&#x2F;&#x2F;当前层的元素
        while(!deque.isEmpty())&#123;
            int size&#x3D;deque.size();
            List&lt;Integer&gt;list&#x3D;new ArrayList&lt;&gt;();
            while(size!&#x3D;0)&#123;
                TreeNode node&#x3D;deque.removeFirst();
                if(node.left!&#x3D;null)&#123;
                    deque.add(node.left);
                &#125;
                if(node.right!&#x3D;null)&#123;
                    deque.add(node.right);
                &#125;
                list.add(node.val);
                size--;
            &#125;
            result.add(list);
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="二叉树的层序遍历2"><a href="#二叉树的层序遍历2" class="headerlink" title="二叉树的层序遍历2"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">二叉树的层序遍历2</a></h4><p>从底向上遍历二叉树，不需要将此题想的过于复杂，可以直接将从上向下遍历后的集合进行倒序即可。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">Collections.reverse(result);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view">二叉树的右视图</a></h4><p>通过题目描述，自然的想到获取层次遍历的每一层最后一个元素即可。所以只需要在层次遍历的代码上面微调即可。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-08 09:36:12
 * @description: 二叉树的右视图
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;
        Deque&lt;TreeNode&gt;deque&#x3D;new ArrayDeque&lt;&gt;();
        if(root!&#x3D;null)&#123;
            deque.add(root);
        &#125;
        List&lt;Integer&gt;list&#x3D;new ArrayList&lt;&gt;();
        while(!deque.isEmpty())&#123;
            int size&#x3D;deque.size();
            while(size&gt;0)&#123;
                TreeNode node&#x3D;deque.removeFirst();
                if(node.left!&#x3D;null)&#123;
                    deque.add(node.left);
                &#125;
                if(node.right!&#x3D;null)&#123;
                    deque.add(node.right);
                &#125;
                &#x2F;&#x2F;只存储最后一个
                if(size&#x3D;&#x3D;1)&#123;
                    list.add(node.val);
                &#125;
                size--;
            &#125;
        &#125;
        return list;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="二叉树每层的平均值"><a href="#二叉树每层的平均值" class="headerlink" title="二叉树每层的平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">二叉树每层的平均值</a></h4><p>同样是层次遍历代码的修改即可，但是需要注意精度问题。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-08 10:22:36
 * @description: 二叉树的层平均值
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;
        List&lt;Double&gt;result&#x3D;new ArrayList&lt;&gt;();
        Deque&lt;TreeNode&gt;deque&#x3D;new ArrayDeque&lt;&gt;();
        if(root!&#x3D;null)&#123;
            deque.add(root);
        &#125;
        while(!deque.isEmpty())&#123;
            int size&#x3D;deque.size();
            double sum&#x3D;0;
            int tempSize&#x3D;size;
            while(size&gt;0)&#123;
                TreeNode node&#x3D;deque.removeFirst();
                if(node.left!&#x3D;null)&#123;
                    deque.add(node.left);
                &#125;
                if(node.right!&#x3D;null)&#123;
                    deque.add(node.right);
                &#125;
                sum+&#x3D;node.val;
                size--;
            &#125;
            result.add((double)sum&#x2F;tempSize);
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">在每个树行中找最大值</a></h4><h4 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">N叉树的层序遍历</a></h4><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226.翻转二叉树</a> 并不是结点数值的交换，而是结点指针的交换。所以只需要把每个节点的孩子节点交换一下即可。</p>
<h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><p>首先选择遍历顺序，最好使用前序和后序。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-09 10:03:33
 * @description: 递归法前序翻转二叉树
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public TreeNode invert(TreeNode root)&#123;
        if(root&#x3D;&#x3D;null)&#123;
            return null;
        &#125;
        &#x2F;&#x2F;中
        TreeNode node&#x3D; root.left;
        root.left&#x3D;root.right;
        root.right&#x3D;node;
        &#x2F;&#x2F;左
        invert(root.left);
        &#x2F;&#x2F;右
        invert(root.right);
        return root;
    &#125;
    public TreeNode invertTree(TreeNode root) &#123;
        return invert(root);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果使用后序的话，交换一下位置即可</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;左
invert(root.left);
&#x2F;&#x2F;右
invert(root.right);
&#x2F;&#x2F;中
TreeNode node&#x3D; root.left;
root.left&#x3D;root.right;
root.right&#x3D;node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是如果使用中序的话，会出现左子树被交换了两次，而右子树并没有被交换</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">      &#x2F;&#x2F;左
      invert(root.left);
&#x2F;&#x2F;中
      TreeNode node&#x3D; root.left;
      root.left&#x3D;root.right;
      root.right&#x3D;node;
      &#x2F;&#x2F;右,需要修改为left
      invert(root.left);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-09 10:31:13
 * @description: 层序遍历翻转二叉树
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public TreeNode invertTree(TreeNode root) &#123;
        Queue&lt;TreeNode&gt;queue&#x3D;new ArrayDeque&lt;&gt;();
        if(root!&#x3D;null)&#123;
            queue.add(root);
        &#125;
        while(!queue.isEmpty())&#123;
            int size&#x3D;queue.size();
            for(int i&#x3D;0;i&lt;size;i++)&#123;
                TreeNode node&#x3D;queue.poll();
                TreeNode temp&#x3D;node.left;
                node.left&#x3D;node.right;
                node.right&#x3D;temp;
                if(node.left!&#x3D;null)&#123;
                    queue.add(node.left);
                &#125;
                if(node.right!&#x3D;null)&#123;
                    queue.add(node.right);
                &#125;
            &#125;
        &#125;
        return root;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<p>主要是判断二叉树的外侧结点是否相等，内侧节点是否相等。使用类后序，因为后序相当于回溯。</p>
<ol>
<li><p>确定递归返回值以及递归参数</p>
<p>因为需要判断左结点和右节点是否相等，所以返回为bool类型，以及参数为左节点和右节点。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean compare(TreeNode left,TreeNode right)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>确定返回条件</p>
<p>一个为空，一个不为空，就代表不对称，就返回false；都为空返回true；都不为空但是值不相等就返回fasle；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)&#123;
           return true;
       &#125;
       else if(left&#x3D;&#x3D;null&amp;&amp;right!&#x3D;null)&#123;
           return false;
       &#125;
       else if(left!&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)&#123;
           return false;
       &#125;
       else if(left.val!&#x3D;right.val)&#123;
           return false;
       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>确定单层递归的逻辑</p>
<p>需要分开遍历外层和内层，只要有一个不符合条件，就返回fasle；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">else&#123;
    		&#x2F;&#x2F;外层
            Boolean outside&#x3D;compare(left.left, right.right);
    		&#x2F;&#x2F;内层
            Boolean inside&#x3D;compare(left.right, right.left);
            return outside&amp;&amp;inside;
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p>代码如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * @Author: 滚筒洗衣机
 * @Date: 2023-06-09 11:20:47
 * @description: 类似后序对称二叉树
 * @return &#123;*&#125;
 *&#x2F;
class Solution &#123;
    public boolean compare(TreeNode left,TreeNode right)&#123;
        if(left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)&#123;
            return true;
        &#125;
        else if(left&#x3D;&#x3D;null&amp;&amp;right!&#x3D;null)&#123;
            return false;
        &#125;
        else if(left!&#x3D;null&amp;&amp;right&#x3D;&#x3D;null)&#123;
            return false;
        &#125;
        else if(left.val!&#x3D;right.val)&#123;
            return false;
        &#125;
        else&#123;
            Boolean outside&#x3D;compare(left.left, right.right);
            Boolean inside&#x3D;compare(left.right, right.left);
            return outside&amp;&amp;inside;
        &#125;
    &#125;
    public boolean isSymmetric(TreeNode root) &#123;
        return compare(root.left, root.right);

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h1 id="leetcode周赛"><a href="#leetcode周赛" class="headerlink" title="leetcode周赛"></a>leetcode周赛</h1><h2 id="第348场"><a href="#第348场" class="headerlink" title="第348场"></a>第348场</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-348/">周赛第348场leetcode链接</a></p>
<h4 id="第一题-最小化字符串长度"><a href="#第一题-最小化字符串长度" class="headerlink" title="第一题 最小化字符串长度"></a>第一题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimize-string-length/">最小化字符串长度</a></h4><p>此题难度不大，其实就是消除相同字母，然后只留一个。可以使用数组或者hashmap作为数据结构来进行存储。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
* @Author: 滚筒洗衣机
* @Description: leetcode周赛第三百348场 2716
* @DateTime: 2023-6-5 10:53
* @Params: 
* @Return 
*&#x2F;
class Solution &#123;
    public int minimizedStringLength(String s) &#123;
        int[]hash&#x3D;new int[128];
        int result&#x3D;0;
        for(int i&#x3D;0;i&lt;s.length();i++)&#123;
            if(hash[s.charAt(i)]&#x3D;&#x3D;0 )&#123;
                hash[s.charAt(i)]++;
            &#125;
            else if(hash[s.charAt(i)]&#x3D;&#x3D;1 )&#123;
            &#125;
            else&#123;
                hash[s.charAt(i)]--;
            &#125;
        &#125;
        for(int i&#x3D;0;i&lt;hash.length;i++)&#123;
            if(hash[i]&#x3D;&#x3D;1)&#123;
                result++;
            &#125;
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="第二题-半有序化排列"><a href="#第二题-半有序化排列" class="headerlink" title="第二题 半有序化排列"></a>第二题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/semi-ordered-permutation/">半有序化排列</a></h4><p>此题也是简单题，不涉及任何算法，主要就是数学推导公式，需要注意的是分类讨论，即最大的数和最小的数字的位置先后不同，计算方式也不同</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
* @Author: 滚筒洗衣机
* @Description: leetcode周赛第三百348场 2717
* @DateTime: 2023-6-5 10:54
* @Params: 
* @Return 
*&#x2F;    
class Solution &#123;
    public int semiOrderedPermutation(int[] nums) &#123;
        int max&#x3D;nums[nums.length-1];
        int min&#x3D;nums[0];
        int maxTag&#x3D;nums.length-1,minTag&#x3D;0;
        int result&#x3D;0;
        &#x2F;&#x2F;找到最大的数及其下标
        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            if(nums[i]&gt;max)&#123;
                max&#x3D;nums[i];
                maxTag&#x3D;i;
            &#125;
        &#125; 
        &#x2F;&#x2F;找到最小的数及其下标
        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            if(nums[i]&lt;min)&#123;
                min&#x3D;nums[i];
                minTag&#x3D;i;
            &#125;
        &#125;
        &#x2F;&#x2F;大数在小数前
        if(maxTag&gt;minTag)&#123;
            result&#x3D;minTag+ (nums.length-1-maxTag);
        &#125;
         &#x2F;&#x2F;大数在小数后
        else &#123;
            result&#x3D;minTag+ (nums.length-1-maxTag)-1;
        &#125;
        return  result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="第二题-查询后矩阵的和"><a href="#第二题-查询后矩阵的和" class="headerlink" title="第二题 查询后矩阵的和"></a>第二题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-matrix-after-queries/">查询后矩阵的和</a></h4><p>此题难度较大，通过率较低，但是题目相对简单，主要是按照普通暴力破解法会导致提交用例超时。</p>
<ul>
<li><p>首先第一个需要注意的地方是由于后面的数组会覆盖前面的数字，所以只需要从后向前遍历，对于已经赋值的位置不再赋值（因为从后向前，第一次赋值极为最终的值）</p>
</li>
<li><p>第二点就是由于只需要计算矩阵的和，不需要关心每个位置的数字，并且每次赋值都是对行或列赋一样的值，所以只需要直接在赋值时进行加法计算</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">sum+&#x3D;row*queries[i][2];
sum+&#x3D;col*queries[i][2];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>第三个注意点就是如何保证已经赋值的位置不再被重新赋值，所以需要使用hashset来记录已经被赋值的行和列</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">HashSet&lt;Integer&gt;colset&#x3D;new HashSet&lt;&gt;();
HashSet&lt;Integer&gt;rowset&#x3D;new HashSet&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<p>代码如下</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">   &#x2F;**
    * @Author: 滚筒洗衣机
    * @Description: leetcode周赛第348场 2718
    * @DateTime: 2023-6-5 11:21
    * @Params: 
    * @Return 
    *&#x2F;
class Solution &#123;
        public long matrixSumQueries(int n, int[][] queries) &#123;
            long sum&#x3D;0;
            int col&#x3D;n;
            int row&#x3D;n;
            HashSet&lt;Integer&gt;colset&#x3D;new HashSet&lt;&gt;();
            HashSet&lt;Integer&gt;rowset&#x3D;new HashSet&lt;&gt;();
            for(int i&#x3D; queries.length-1;i&gt;&#x3D;0;i--)&#123;
                if((queries[i][0]&#x3D;&#x3D;0)&amp;&amp;!rowset.contains(queries[i][1]))&#123;
                    sum+&#x3D;row*queries[i][2];
                    &#x2F;&#x2F;代表此位置已经相加，当列需要加此位置时候，忽略此位置
                    col--;
                    rowset.add(queries[i][1]);
                &#125;
                if((queries[i][0]&#x3D;&#x3D;1)&amp;&amp;!colset.contains(queries[i][1]))&#123;
                    sum+&#x3D;col*queries[i][2];
                    row--;
                    colset.add(queries[i][1]);
                &#125;
            &#125;
            return sum;
        &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第347场"><a href="#第347场" class="headerlink" title="第347场"></a>第347场</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-347/">周赛第347场leetcode链接</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># -leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/01/java-web/" rel="prev" title="java_web">
      <i class="fa fa-chevron-left"></i> java_web
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/05/git/" rel="next" title="git">
      git <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">双指针法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">6.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">7.1.</span> <span class="nav-text">二叉树基本知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">7.2.</span> <span class="nav-text">小技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.</span> <span class="nav-text">二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="nav-number">7.3.1.</span> <span class="nav-text">递归法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="nav-number">7.3.2.</span> <span class="nav-text">迭代法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">后序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-number">7.3.3.</span> <span class="nav-text">层序遍历（使用队列)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">二叉树的层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%862"><span class="nav-number">7.3.3.2.</span> <span class="nav-text">二叉树的层序遍历2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">7.3.3.3.</span> <span class="nav-text">二叉树的右视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">7.3.3.4.</span> <span class="nav-text">二叉树每层的平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">7.3.3.5.</span> <span class="nav-text">在每个树行中找最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.3.6.</span> <span class="nav-text">N叉树的层序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.3.4.</span> <span class="nav-text">翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B3%95-1"><span class="nav-number">7.3.4.1.</span> <span class="nav-text">递归法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95-1"><span class="nav-number">7.3.4.2.</span> <span class="nav-text">迭代法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.4.3.</span> <span class="nav-text">层序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.3.5.</span> <span class="nav-text">对称二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">回溯算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">贪心算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">10.</span> <span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">11.</span> <span class="nav-text">单调栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">12.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode%E5%91%A8%E8%B5%9B"><span class="nav-number">13.</span> <span class="nav-text">leetcode周赛</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC348%E5%9C%BA"><span class="nav-number">13.1.</span> <span class="nav-text">第348场</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="nav-number">13.1.0.1.</span> <span class="nav-text">第一题 最小化字符串长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-%E5%8D%8A%E6%9C%89%E5%BA%8F%E5%8C%96%E6%8E%92%E5%88%97"><span class="nav-number">13.1.0.2.</span> <span class="nav-text">第二题 半有序化排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98-%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="nav-number">13.1.0.3.</span> <span class="nav-text">第二题 查询后矩阵的和</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC347%E5%9C%BA"><span class="nav-number">13.2.</span> <span class="nav-text">第347场</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">GunTongXiYiJi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GunTongXiYiJi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'n0LoK2hRrrBD3U6fvle0ZapC-gzGzoHsz',
      appKey     : 'aFzAdYNfKGP41raXev2d3Fre',
      placeholder: "期待你的评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
